# ==================== Stack ====================

## stack using araay
class Array:
    def __init__(self, capacity):
        self.capacity = capacity
        self.array = [None] * capacity
        self.size = 0
    
    def insert(self, index, value):
        if self.size >= self.capacity:
            raise OverflowError("Array is full")
        if index < 0 or index > self.size:
            raise IndexError("Index out of bounds")
        for i in range(self.size, index, -1):
            self.array[i] = self.array[i - 1]
        self.array[index] = value
        self.size += 1
    
    def remove(self, index):
        if self.size == 0:
            raise IndexError("Array is empty")
        if index < 0 or index >= self.size:
            raise IndexError("Index out of bounds")
        value = self.array[index]
        for i in range(index, self.size - 1):
            self.array[i] = self.array[i + 1]
        self.array[self.size - 1] = None
        self.size -= 1
        return value
    
    def get(self, index):
        if index < 0 or index >= self.size:
            raise IndexError("Index out of bounds")
        return self.array[index]
    
    def is_empty(self):
        return self.size == 0
    
    def is_full(self):
        return self.size == self.capacity
    
    def __str__(self):
        return str(self.array[:self.size])

class Stack:
    def __init__(self, capacity):
        self.array = Array(capacity)
    
    def push(self, value):
        if self.array.is_full():
            raise OverflowError("Stack overflow")
        self.array.insert(self.array.size, value)
    
    def pop(self):
        if self.array.is_empty():
            raise IndexError("Stack underflow")
        return self.array.remove(self.array.size - 1)
    
    def peek(self):
        if self.array.is_empty():
            return None  
        return self.array.get(self.array.size - 1)
    
    def is_empty(self):
        return self.array.is_empty()
    
    def is_full(self):
        return self.array.is_full()
    
    def __str__(self):
        return str(self.array)

if __name__ == "__main__":
    stack = Stack(5)
    stack.push(10)
    stack.push(20)
    stack.push(30)
    print("Stack:", stack)
    print("Popped element:", stack.pop())
    print("Stack after pop:", stack)
    if not stack.is_empty():
        print("Top element:", stack.peek())
    else:
        print("Stack is empty after pop")
        
    print("-------")
    print("Stack:", stack)
    print("Popped element:", stack.pop())
    print("Stack after pop:", stack)
    if not stack.is_empty():
        print("Top element:", stack.peek())
    else:
        print("Stack is empty after pop")
        
    print("-------")
    print("Stack:", stack)
    print("Popped element:", stack.pop())
    print("Stack after pop:", stack)
    if not stack.is_empty():
        print("Top element:", stack.peek())
    else:
        print("Stack is empty after pop")

################################################################################

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
    
    def insert_at_beginning(self, value):
        new_node = Node(value)
        new_node.next = self.head
        self.head = new_node
    
    def remove_from_beginning(self):
        if self.is_empty():
            raise IndexError("Stack is empty")
        value = self.head.value
        self.head = self.head.next
        return value
    
    def get_first(self):
        if self.is_empty():
            return None
        return self.head.value
    
    def is_empty(self):
        return self.head is None
    
    def __str__(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.value)
            current = current.next
        return str(elements)

class Stack:
    def __init__(self):
        self.linked_list = LinkedList()
    
    def push(self, value):
        self.linked_list.insert_at_beginning(value)
    
    def pop(self):
        return self.linked_list.remove_from_beginning()
    
    def peek(self):
        return self.linked_list.get_first()
    
    def is_empty(self):
        return self.linked_list.is_empty()
    
    def __str__(self):
        return str(self.linked_list)

if __name__ == "__main__":
    stack = Stack()
    stack.push(10)
    stack.push(20)
    stack.push(30)
    print("Stack:", stack)
    print("Popped element:", stack.pop())
    print("Stack after pop:", stack)
    
    if not stack.is_empty():
        print("Top element:", stack.peek())
    else:
        print("Stack is empty after pop")
        
    print("------")
    print("Popped element:", stack.pop())
    print("Stack after pop:", stack)
    
    if not stack.is_empty():
        print("Top element:", stack.peek())
    else:
        print("Stack is empty after pop")
        
    print("------")
    print("Popped element:", stack.pop())
    print("Stack after pop:", stack)
    
    if not stack.is_empty():
        print("Top element:", stack.peek())
    else:
        print("Stack is empty after pop")

################################################################################

a = "abc"
print(type(a))

################################################################################

a = a + "d"
print(a)

################################################################################

type(a)

################################################################################



################################################################################

'''
Valid paranthesis

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
 

Example 1:

Input: s = "()"

Output: true

Example 2:

Input: s = "()[]{}"

Output: true

Example 3:

Input: s = "(]"

Output: false

Example 4:

Input: s = "([])"

Output: true

'''

class Array:
    def __init__(self, capacity):
        self.capacity = capacity
        self.array = [None] * capacity
        self.size = 0
    
    def insert(self, index, value):
        if self.size >= self.capacity:
            raise OverflowError("Array is full")
        if index < 0 or index > self.size:
            raise IndexError("Index out of bounds")
        for i in range(self.size, index, -1):
            self.array[i] = self.array[i - 1]
        self.array[index] = value
        self.size += 1
    
    def remove(self, index):
        if self.size == 0:
            raise IndexError("Array is empty")
        if index < 0 or index >= self.size:
            raise IndexError("Index out of bounds")
        value = self.array[index]
        for i in range(index, self.size - 1):
            self.array[i] = self.array[i + 1]
        self.array[self.size - 1] = None
        self.size -= 1
        return value
    
    def get(self, index):
        if index < 0 or index >= self.size:
            raise IndexError("Index out of bounds")
        return self.array[index]
    
    def is_empty(self):
        return self.size == 0
    
    def is_full(self):
        return self.size == self.capacity
    
    def __str__(self):
        return str(self.array[:self.size])

class Stack:
    def __init__(self, capacity):
        self.array = Array(capacity)
    
    def push(self, value):
        if self.array.is_full():
            raise OverflowError("Stack overflow")
        self.array.insert(self.array.size, value)
    
    def pop(self):
        if self.array.is_empty():
            raise IndexError("Stack underflow")
        return self.array.remove(self.array.size - 1)
    
    def peek(self):
        if self.array.is_empty():
            return None  
        return self.array.get(self.array.size - 1)
    
    def is_empty(self):
        return self.array.is_empty()
    
    def is_full(self):
        return self.array.is_full()
    
    def __str__(self):
        return str(self.array)

def is_valid_parentheses(s):
    stack = Stack(len(s))
    bracket_map = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in bracket_map.values():
            stack.push(char)
        elif char in bracket_map.keys():
            if stack.is_empty() or stack.pop() != bracket_map[char]:
                return False
    
    return stack.is_empty()

if __name__ == "__main__":
    test_cases = ["()", "()[]{}", "(]", "([])"]
    for s in test_cases:
        print(f"Input: {s} -> Output: {is_valid_parentheses(s)}")

################################################################################

'''
Given two integer arrays pushed and popped each with distinct values, 
return true if this could have been the result of a sequence of push and pop operations 
on an initially empty stack, or false otherwise.

 
Example 1:

Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
Output: true
Explanation: We might do the following sequence:
push(1), push(2), push(3), push(4),
pop() -> 4,
push(5),
pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
Example 2:

Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
Output: false
Explanation: 1 cannot be popped before 2.
'''

class Array:
    def __init__(self):
        self.data = [None] * 100 
        self.size = 0  
    
    def insert(self, value):
        if self.size < len(self.data):
            self.data[self.size] = value
            self.size += 1
    
    def remove(self):
        if not self.is_empty():
            value = self.data[self.size - 1]
            self.size -= 1
            return value
        return None
    
    def peek(self):
        if not self.is_empty():
            return self.data[self.size - 1]
        return None
    
    def is_empty(self):
        return self.size == 0


class Stack:
    def __init__(self):
        self.array = Array()  
    
    def push(self, value):
        self.array.insert(value)
    
    def pop(self):
        return self.array.remove()
    
    def peek(self):
        return self.array.peek()
    
    def is_empty(self):
        return self.array.is_empty()


class StackValidator:
    def __init__(self, pushed, popped):
        self.pushed = pushed  
        self.popped = popped  
        self.stack = Stack()  
        self.index = 0  
    
    def validate(self):
        for value in self.pushed:
            self.stack.push(value)
            while (not self.stack.is_empty() and self.index < len(self.popped) and 
                   self.stack.peek() == self.popped[self.index]):
                self.stack.pop()
                self.index += 1
        
        return self.stack.is_empty()


pushed = [1, 2, 3, 4, 5]
popped = [4, 5, 3, 2, 1]
validator = StackValidator(pushed, popped)
print(validator.validate()) 

pushed2 = [1, 2, 3, 4, 5]
popped2 = [4, 3, 5, 1, 2]
validator2 = StackValidator(pushed2, popped2)
print(validator2.validate())  

################################################################################

'''
You are given an integer array nums, an integer k, and an integer multiplier.

You need to perform k operations on nums. In each operation:

Find the minimum value x in nums. If there are multiple occurrences of the minimum value, select the one that appears first.
Replace the selected minimum value x with x * multiplier.
Return an integer array denoting the final state of nums after performing all k operations.

 

Example 1:

Input: nums = [2,1,3,5,6], k = 5, multiplier = 2

Output: [8,4,6,5,6]
'''

class Array:
    def __init__(self, size):
        self.data = [None] * size  
        self.size = size  
        self.top = -1  

    def insert(self, index, value):
        if 0 <= index < self.size:
            self.data[index] = value
    
    def get(self, index):
        if 0 <= index < self.size:
            return self.data[index]
        return None

    def get_array(self):
        return self.data


class Stack:
    def __init__(self, size):
        self.array = Array(size)

    def push(self, value):
        if self.array.top < self.array.size - 1:
            self.array.top += 1
            self.array.insert(self.array.top, value)
    
    def pop(self):
        if self.array.top >= 0:
            value = self.array.get(self.array.top)
            self.array.top -= 1
            return value
        return None
    
    def peek(self, index):
        if 0 <= index <= self.array.top:
            return self.array.get(index)
        return None
    
    def find_min_index(self):
        min_index = 0
        for i in range(1, self.array.top + 1):
            if self.array.get(i) < self.array.get(min_index):
                min_index = i
        return min_index
    
    def multiply_at_index(self, index, multiplier):
        if 0 <= index <= self.array.top:
            self.array.data[index] *= multiplier
    
    def print_stack(self):
        print(self.get_stack())

    def get_stack(self):
        return self.array.get_array()[:self.array.top + 1]


def modify_array(nums, k, multiplier):
    stack = Stack(len(nums))
    for num in nums:
        stack.push(num)
    
    for _ in range(k):
        min_index = stack.find_min_index()
        stack.multiply_at_index(min_index, multiplier)
        stack.print_stack()  
    
    return stack.get_stack()

nums = [2, 1, 3, 5, 6]
k = 5
multiplier = 2
print(modify_array(nums, k, multiplier))  

################################################################################

'''
There are n mountains in a row, and each mountain has a height. You are given an integer array height where height[i] represents the height of mountain i, and an integer threshold.

A mountain is called stable if the mountain just before it (if it exists) has a height strictly greater than threshold. Note that mountain 0 is not stable.

Return an array containing the indices of all stable mountains in any order.

 

Example 1:

Input: height = [1,2,3,4,5], threshold = 2

Output: [3,4]

Explanation:

Mountain 3 is stable because height[2] == 3 is greater than threshold == 2.
Mountain 4 is stable because height[3] == 4 is greater than threshold == 2.
Example 2:

Input: height = [10,1,10,1,10], threshold = 3

Output: [1,3]

Example 3:

Input: height = [10,1,10,1,10], threshold = 10

Output: []
'''

class Array:
    def __init__(self, size):
        self.data = [None] * size  
        self.size = size
        self.top = -1  

    def insert(self, index, value):
        if 0 <= index < self.size:
            self.data[index] = value
    
    def get(self, index):
        if 0 <= index < self.size:
            return self.data[index]
        return None
    
    def get_array(self):
        return self.data


class Stack:
    def __init__(self, size):
        self.array = Array(size)

    def push(self, value):
        if self.array.top < self.array.size - 1:
            self.array.top += 1
            self.array.insert(self.array.top, value)
    
    def pop(self):
        if self.array.top >= 0:
            value = self.array.get(self.array.top)
            self.array.top -= 1
            return value
        return None


def find_stable_mountains(height, threshold):
    n = len(height)
    array = Array(n)
    for i in range(n):
        array.insert(i, height[i])
    
    stable_mountains = []
    for i in range(1, n):
        if array.get(i - 1) > threshold:
            stable_mountains.append(i)
    
    return stable_mountains

height = [1, 2, 3, 4, 5]
threshold = 2
print(find_stable_mountains(height, threshold)) 

height = [10, 1, 10, 1, 10]
threshold = 3
print(find_stable_mountains(height, threshold))  

height = [10, 1, 10, 1, 10]
threshold = 10
print(find_stable_mountains(height, threshold))  

################################################################################

'''
You are given a large sample of integers in the range [0, 255]. 
Since the sample is so large, it is represented by an array count where count[k] 
is the number of times that k appears in the sample.

Calculate the following statistics:

minimum: The minimum element in the sample.
maximum: The maximum element in the sample.
mean: The average of the sample, calculated as the total sum of all elements divided by the total number of elements.
median:
If the sample has an odd number of elements, 
then the median is the middle element once the sample is sorted.

If the sample has an even number of elements, 
then the median is the average of the two middle elements once the sample is sorted.

mode: The number that appears the most in the sample. It is guaranteed to be unique.

Return the statistics of the sample as an array of floating-point numbers 
[minimum, maximum, mean, median, mode]. Answers within 10-5 of the actual answer will be accepted.
'''

class Array:
    def __init__(self, size):
        self.data = [0] * size  
        self.size = size
        self.top = -1  

    def insert(self, index, value):
        if 0 <= index < self.size:
            self.data[index] = value
    
    def get(self, index):
        if 0 <= index < self.size:
            return self.data[index]
        return None
    
    def get_array(self):
        return self.data

    def find_min(self):
        for i in range(self.size):
            if self.data[i] > 0:
                return i
        return None
    
    def find_max(self):
        for i in range(self.size - 1, -1, -1):
            if self.data[i] > 0:
                return i
        return None
    
    def total_sum(self):
        return sum(i * self.data[i] for i in range(self.size))
    
    def total_count(self):
        return sum(self.data)
    
    def find_mode(self):
        return max(range(self.size), key=lambda x: self.data[x])
    
    def find_median(self):
        count = self.total_count()
        mid1, mid2 = (count // 2, (count // 2) + 1) if count % 2 == 0 else (count // 2, count // 2)
        freq_sum = 0
        median1 = median2 = None
        
        for i in range(self.size):
            freq_sum += self.data[i]
            if median1 is None and freq_sum >= mid1:
                median1 = i
            if median2 is None and freq_sum >= mid2:
                median2 = i
                break
        
        return (median1 + median2) / 2


class Stack:
    def __init__(self, size):
        self.array = Array(size)
    
    def push(self, index, value):
        self.array.insert(index, value)
    
    def get_statistics(self):
        minimum = self.array.find_min()
        maximum = self.array.find_max()
        mean = self.array.total_sum() / self.array.total_count()
        median = self.array.find_median()
        mode = self.array.find_mode()
        return [minimum, maximum, mean, median, mode]


def calculate_statistics(count):
    stack = Stack(len(count))
    for i in range(len(count)):
        stack.push(i, count[i])
    
    print("Index  | Frequency")
    print("------------------")
    for i in range(len(count)):
        if count[i] > 0:
            print(f"  {i}    |    {count[i]}")
    
    return stack.get_statistics()

count = [0] * 256
count[0] = 5
count[10] = 2
count[20] = 3
print(calculate_statistics(count))  

################################################################################

'''
Given a postfix expression, the task is to evaluate the postfix expression. 
A Postfix expression is of the form “a b operator” (“a b +”) i.e., a pair of operands is followed by an operator.

Examples:

Input: arr = [“2”, “3”, “1”, “*”, “+”, “9”, “-“]
Output: -4
Explanation: If the expression is converted into an infix expression, it will be 2 + (3 * 1) – 9 = 5 – 9 = -4.


Input: arr = [“100”, “200”, “+”, “2”, “/”, “5”, “*”, “7”, “+”]
Output: 757
Explanation: If the expression is converted into an infix expression, 
it will be ((100 + 200) / 2) * 5 + 7  = 150 * 5 + 7 = 757."
'''

class Array:
    def __init__(self, size):
        self.data = [0] * size  
        self.size = size
        self.top = -1  

    def insert(self, index, value):
        if 0 <= index < self.size:
            self.data[index] = value
    
    def get(self, index):
        if 0 <= index < self.size:
            return self.data[index]
        return None
    
    def get_array(self):
        return self.data

class Stack:
    def __init__(self, size):
        self.array = Array(size)
    
    def push(self, value):
        if self.array.top < self.array.size - 1:
            self.array.top += 1
            self.array.insert(self.array.top, value)
    
    def pop(self):
        if self.array.top >= 0:
            value = self.array.get(self.array.top)
            self.array.top -= 1
            return value
        return None
    
    def is_empty(self):
        return self.array.top == -1

def evaluate_postfix(expression):
    stack = Stack(len(expression))
    
    for token in expression:
        if token.isdigit():
            stack.push(int(token))
        else:
            b = stack.pop()
            a = stack.pop()
            if token == '+':
                stack.push(a + b)
            elif token == '-':
                stack.push(a - b)
            elif token == '*':
                stack.push(a * b)
            elif token == '/':
                stack.push(a // b)  
    
    return stack.pop()

# Example usage
expression1 = ["2", "3", "1", "*", "+", "9", "-"]
expression2 = ["100", "200", "+", "2", "/", "5", "*", "7", "+"]
print(evaluate_postfix(expression1)) 
print(evaluate_postfix(expression2))  

################################################################################

'''
You are given an arithmetic expression in infix notation, containing integers and the operators 
+, -, *, /, and parentheses (). Your task is to convert this infix expression into a postfix (Reverse Polish) 
notation using a stack-based approach.

Example 1:
Input: (3+5)*2
Output: 3 5 + 2 *

Example 2:
Input: 10+20*30
Output: 10 20 30 * +
'''

class Array:
    def __init__(self, size):
        self.data = [0] * size  
        self.size = size
        self.top = -1  

    def insert(self, index, value):
        if 0 <= index < self.size:
            self.data[index] = value
    
    def get(self, index):
        if 0 <= index < self.size:
            return self.data[index]
        return None
    
    def get_array(self):
        return self.data

class Stack:
    def __init__(self, size):
        self.array = Array(size)
    
    def push(self, value):
        if self.array.top < self.array.size - 1:
            self.array.top += 1
            self.array.insert(self.array.top, value)
    
    def pop(self):
        if self.array.top >= 0:
            value = self.array.get(self.array.top)
            self.array.top -= 1
            return value
        return None
    
    def peek(self):
        if self.array.top >= 0:
            return self.array.get(self.array.top)
        return None
    
    def is_empty(self):
        return self.array.top == -1

def precedence(op):
    if op in ('+', '-'):
        return 1
    if op in ('*', '/'):
        return 2
    return 0

def infix_to_postfix(expression):
    stack = Stack(len(expression))
    output = []
    
    for token in expression:
        if token.isdigit():  
            output.append(token)
        elif token == '(':
            stack.push(token)
        elif token == ')':
            while not stack.is_empty() and stack.peek() != '(':
                output.append(stack.pop())
            stack.pop()  
        else:  
            while not stack.is_empty() and precedence(stack.peek()) >= precedence(token):
                output.append(stack.pop())
            stack.push(token)
    
    while not stack.is_empty():
        output.append(stack.pop())
    
    return output

def parse_expression(expression):
    tokens = []
    num = ""
    for char in expression:
        if char.isdigit():
            num += char  
        else:
            if num:
                tokens.append(num)
                num = ""
            if char in '+-*/()':
                tokens.append(char)
    if num:
        tokens.append(num)  
    return tokens

expression = input("Enter an infix expression: ")
tokens = parse_expression(expression)
print("Postfix expression:", ' '.join(infix_to_postfix(tokens)))

################################################################################



################################################################################

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self):
        self.front = None
        self.rear = None
        self.size = 0

    def enqueue(self, x):
        new_node = Node(x)
        if self.rear is None:
            self.front = self.rear = new_node
        else:
            self.rear.next = new_node
            self.rear = new_node
        self.size += 1

    def dequeue(self):
        if self.isEmpty():
            return "Queue is empty"
        data = self.front.data
        self.front = self.front.next
        if self.front is None:
            self.rear = None
        self.size -= 1
        return data

    def isEmpty(self):
        return self.front is None

    def frontValue(self):
        return self.front.data if self.front else "Queue is empty"

    def getSize(self):
        return self.size

    def display(self):
        temp = self.front
        elements = []
        while temp:
            elements.append(temp.data)
            temp = temp.next
        print(elements)

# Stack class using two Queues (Push Costly)
class StackPushCostly:
    def __init__(self):
        self.q1 = Queue()
        self.q2 = Queue()

    def push(self, x):
        while not self.q1.isEmpty():
            self.q2.enqueue(self.q1.dequeue())
        self.q1.enqueue(x)
        while not self.q2.isEmpty():
            self.q1.enqueue(self.q2.dequeue())

    def pop(self):
        return self.q1.dequeue() if not self.q1.isEmpty() else "Stack is empty"

    def top(self):
        return self.q1.frontValue()

    def display(self):
        self.q1.display()

# Stack class using two Queues (Pop Costly)
class StackPopCostly:
    def __init__(self):
        self.q1 = Queue()
        self.q2 = Queue()

    def push(self, x):
        self.q1.enqueue(x)

    def pop(self):
        if self.q1.isEmpty():
            return "Stack is empty"
        while self.q1.getSize() > 1:
            self.q2.enqueue(self.q1.dequeue())
        popped = self.q1.dequeue()
        self.q1, self.q2 = self.q2, self.q1
        return popped

    def top(self):
        if self.q1.isEmpty():
            return "Stack is empty"
        return self.q1.frontValue()

    def display(self):
        self.q1.display()

print("Push Costly Approach:")
stack1 = StackPushCostly()
stack1.push(1)
stack1.push(2)
stack1.push(3)
stack1.display()
print("Popped Element:", stack1.pop())
stack1.display()

print("\nPop Costly Approach:")
stack2 = StackPopCostly()
stack2.push(1)
stack2.push(2)
stack2.push(3)
stack2.display()
print("Popped Element:", stack2.pop())
stack2.display()

################################################################################



################################################################################

# ==================== Queue ====================

class Array:
    def __init__(self, capacity):
        self.capacity = capacity
        self.arr = [None] * capacity  
        self.size = 0
        self.front = 0
        self.rear = -1

    def insert(self, value):
        if self.rear + 1 >= self.capacity:
            print("Insertion failed: Array is full")
            return
        self.rear += 1
        self.arr[self.rear] = value
        self.size += 1

    def remove(self):
        if self.front > self.rear:
            print("Deletion failed: Array is empty")
            return
        self.arr[self.front] = None 
        self.front += 1
        self.size -= 1

    def get_front(self):
        if self.front > self.rear:
            print("Access failed: Queue is empty")
            return None
        return self.arr[self.front]

    def is_empty(self):
        return self.front > self.rear

    def is_full(self):
        return self.rear + 1 == self.capacity

    def get_size(self):
        return self.size


class Queue:
    def __init__(self, capacity):
        self.arr = Array(capacity)

    def enqueue(self, value):
        self.arr.insert(value)

    def dequeue(self):
        self.arr.remove()

    def peek(self):
        return self.arr.get_front()

    def is_empty(self):
        return self.arr.is_empty()

    def is_full(self):
        return self.arr.is_full()


if __name__ == "__main__":
    q = Queue(5)
    q.enqueue(10)
    q.enqueue(20)
    q.enqueue(30)
    print("Front element:", q.peek())  
    q.dequeue()
    print("Front element after dequeue:", q.peek())  

################################################################################

class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0

    def append(self, value):
        new_node = Node(value)
        if self.tail:
            self.tail.next = new_node
        else:
            self.head = new_node
        self.tail = new_node
        self.size += 1

    def remove_first(self):
        if not self.head:
            raise IndexError("Queue underflow")
        value = self.head.value
        self.head = self.head.next
        if self.head is None:
            self.tail = None
        self.size -= 1
        return value

    def get_first(self):
        if not self.head:
            raise IndexError("Queue is empty")
        return self.head.value

    def is_empty(self):
        return self.head is None

    def display(self):
        elements = []
        current = self.head
        while current:
            elements.append(current.value)
            current = current.next
        print("Queue elements:", elements)

class Queue:
    def __init__(self):
        self.linked_list = LinkedList()

    def enqueue(self, value):
        self.linked_list.append(value)

    def dequeue(self):
        return self.linked_list.remove_first()

    def front(self):
        return self.linked_list.get_first()

    def is_empty(self):
        return self.linked_list.is_empty()

    def display(self):
        self.linked_list.display()

queue = Queue()
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)
queue.display()  
print("Front element:", queue.front())  
print("Dequeued element:", queue.dequeue())  
queue.display()  
print("Queue empty?", queue.is_empty())  

################################################################################

class Node:
    def __init__(self, data, priority):
        self.data = data
        self.priority = priority
        self.next = None


class LinkedList:
    def __init__(self):
        self.head = None

    def is_empty(self):
        return self.head is None

    def insert(self, data, priority):
        new_node = Node(data, priority)
        if self.is_empty() or self.head.priority < priority:
            new_node.next = self.head
            self.head = new_node
        else:
            temp = self.head
            while temp.next and temp.next.priority >= priority:
                temp = temp.next
            new_node.next = temp.next
            temp.next = new_node

    def remove_first(self):
        if self.is_empty():
            print("Queue is empty!")
            return None
        removed_node = self.head
        self.head = self.head.next
        return removed_node.data

    def display(self):
        if self.is_empty():
            print("Queue is empty!")
            return
        temp = self.head
        print("Priority Queue:")
        while temp:
            print(f"Data: {temp.data}, Priority: {temp.priority}")
            temp = temp.next


class PriorityQueue:
    def __init__(self):
        self.linked_list = LinkedList()

    def insert(self, data, priority):
        self.linked_list.insert(data, priority)

    def delete(self):
        return self.linked_list.remove_first()
    
    def display(self):
        self.linked_list.display()


pq = PriorityQueue()
pq.insert("Task1", 2)
pq.insert("Task2", 1)
pq.insert("Task3", 3)
pq.insert("Task4", 0)
pq.insert("Task5", 2)

pq.display()

print("Deleted:", pq.delete())
pq.display()

################################################################################

class Array:
    def __init__(self, capacity):
        self.capacity = capacity
        self.array = [None] * capacity
        self.front = -1
        self.rear = -1

    def isFull(self):
        return (self.rear + 1) % self.capacity == self.front

    def isEmpty(self):
        return self.front == -1

    def insert(self, value):
        if self.isFull():
            print("Queue overflow")
            return
        if self.isEmpty():
            self.front = 0
        self.rear = (self.rear + 1) % self.capacity
        self.array[self.rear] = value

    def remove(self):
        if self.isEmpty():
            print("Queue underflow")
            return None
        value = self.array[self.front]
        if self.front == self.rear:
            self.front = -1
            self.rear = -1
        else:
            self.front = (self.front + 1) % self.capacity
        return value

    def getFront(self):
        if self.isEmpty():
            print("Queue is empty")
            return None
        return self.array[self.front]

    def printQueue(self):
        if self.isEmpty():
            print("Queue is empty")
            return
        index = self.front
        elements = []
        while True:
            elements.append(self.array[index])
            if index == self.rear:
                break
            index = (index + 1) % self.capacity
        print("Queue elements:", elements)

class CircularQueue:
    def __init__(self, capacity):
        self.array = Array(capacity)

    def enqueue(self, value):
        self.array.insert(value)

    def dequeue(self):
        return self.array.remove()

    def getFront(self):
        return self.array.getFront()

    def printQueue(self):
        self.array.printQueue()

queue = CircularQueue(5)
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)
queue.printQueue()  
print("Front element:", queue.getFront())  
print("Dequeued element:", queue.dequeue())  
queue.printQueue()  
print("Queue empty?", queue.array.isEmpty()) 

################################################################################

queue = CircularQueue(5)
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
queue.enqueue(4)  
queue.printQueue()
print("front = ",queue.array.front)
print("rear = ",queue.array.rear)
print("---------")
queue.enqueue(5) 
queue.printQueue()
print("front = ",queue.array.front)
print("rear = ",queue.array.rear)
print("---------")
queue.enqueue(6)
queue.printQueue()
print("front = ",queue.array.front)
print("rear = ",queue.array.rear)
print("---------")
queue.dequeue()
queue.dequeue()
queue.printQueue()
print("front = ",queue.array.front)
print("rear = ",queue.array.rear)
print("---------")
queue.enqueue(9)
queue.printQueue()
print("front = ",queue.array.front)
print("rear = ",queue.array.rear)
print("---------")
queue.enqueue(10)
queue.printQueue()
print("front = ",queue.array.front)
print("rear = ",queue.array.rear)
print("---------")
queue.enqueue(11)
queue.printQueue()
print("front = ",queue.array.front)
print("rear = ",queue.array.rear)

################################################################################

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.front = None
        self.rear = None

    def isEmpty(self):
        return self.front is None

    def insert(self, value):
        new_node = Node(value)
        if self.isEmpty():
            self.front = new_node
            self.rear = new_node
            self.rear.next = self.front 
        else:
            self.rear.next = new_node
            self.rear = new_node
            self.rear.next = self.front  

    def remove(self):
        if self.isEmpty():
            print("Queue underflow")
            return None
        value = self.front.data
        if self.front == self.rear:  
            self.front = None
            self.rear = None
        else:
            self.front = self.front.next
            self.rear.next = self.front  
        return value

    def peek(self):
        if self.isEmpty():
            print("Queue is empty")
            return None
        return self.front.data

    def printQueue(self):
        if self.isEmpty():
            print("Queue is empty")
            return
        elements = []
        current = self.front
        while True:
            elements.append(current.data)
            current = current.next
            if current == self.front:
                break
        print("Queue elements:", elements)

class CircularQueue:
    def __init__(self):
        self.linked_list = LinkedList()

    def enqueue(self, value):
        self.linked_list.insert(value)

    def dequeue(self):
        return self.linked_list.remove()

    def get_front(self):
        return self.linked_list.peek()

    def isEmpty(self):
        return self.linked_list.isEmpty()

    def printQueue(self):
        self.linked_list.printQueue()

queue = CircularQueue()
queue.enqueue(10)
queue.enqueue(20)
queue.enqueue(30)
queue.printQueue()  
print("Front element:", queue.get_front()) 
print("Dequeued element:", queue.dequeue())
queue.printQueue() 
print("Queue empty?", queue.isEmpty())  

################################################################################

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None
        self.prev = None

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def isEmpty(self):
        return self.head is None

    def insertFront(self, data):
        new_node = Node(data)
        if self.isEmpty():
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node

    def insertRear(self, data):
        new_node = Node(data)
        if self.isEmpty():
            self.head = self.tail = new_node
        else:
            self.tail.next = new_node
            new_node.prev = self.tail
            self.tail = new_node

    def deleteFront(self):
        if self.isEmpty():
            print("Deque is empty!")
            return None
        data = self.head.data
        self.head = self.head.next
        if self.head is None:
            self.tail = None
        else:
            self.head.prev = None
        return data

    def deleteRear(self):
        if self.isEmpty():
            print("Deque is empty!")
            return None
        data = self.tail.data
        self.tail = self.tail.prev
        if self.tail is None:
            self.head = None
        else:
            self.tail.next = None
        return data

    def getFront(self):
        if self.isEmpty():
            return None
        return self.head.data

    def getRear(self):
        if self.isEmpty():
            return None
        return self.tail.data

    def printQueue(self):
        if self.isEmpty():
            print("Deque is empty!")
            return
        current = self.head
        while current:
            print(current.data, end=" <-> ")
            current = current.next
        print("None")

class Deque:
    def __init__(self):
        self.dll = DoublyLinkedList()

    def insertFront(self, data):
        self.dll.insertFront(data)

    def insertRear(self, data):
        self.dll.insertRear(data)

    def deleteFront(self):
        return self.dll.deleteFront()

    def deleteRear(self):
        return self.dll.deleteRear()

    def getFront(self):
        return self.dll.getFront()

    def getRear(self):
        return self.dll.getRear()

    def printQueue(self):
        self.dll.printQueue()

deque = Deque()
deque.insertFront(10)
deque.insertRear(20)
deque.insertFront(5)
deque.insertRear(25)
deque.printQueue()
print("Front element:", deque.getFront())
print("Rear element:", deque.getRear())
deque.deleteFront()
deque.deleteRear()
deque.printQueue()

################################################################################



################################################################################

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Stack:
    def __init__(self):
        self.top = None

    def push(self, data):
        new_node = Node(data)
        new_node.next = self.top
        self.top = new_node

    def pop(self):
        if self.isEmpty():
            raise IndexError("Stack is empty")
        popped_data = self.top.data
        self.top = self.top.next
        return popped_data

    def peek(self):
        if self.isEmpty():
            raise IndexError("Stack is empty")
        return self.top.data

    def isEmpty(self):
        return self.top is None

class QueueUsingStacksEnqueueCostly:
    def __init__(self):
        self.stack1 = Stack()
        self.stack2 = Stack()

    def enqueue(self, item):
        # Move all elements from stack1 to stack2
        while not self.stack1.isEmpty():
            self.stack2.push(self.stack1.pop())

        # Push new item to stack1
        self.stack1.push(item)

        # Move back all elements to stack1
        while not self.stack2.isEmpty():
            self.stack1.push(self.stack2.pop())

    def dequeue(self):
        if self.stack1.isEmpty():
            raise IndexError("Queue is empty")
        return self.stack1.pop()

    def peek(self):
        if self.stack1.isEmpty():
            raise IndexError("Queue is empty")
        return self.stack1.peek()

    def is_empty(self):
        return self.stack1.isEmpty()

q1 = QueueUsingStacksEnqueueCostly()
q1.enqueue(10)
q1.enqueue(20)
q1.enqueue(30)
print(q1.dequeue())  
print(q1.peek())     
print(q1.is_empty()) 

################################################################################

class QueueUsingStacksDequeueCostly:
    def __init__(self):
        self.stack1 = Stack()
        self.stack2 = Stack()

    def enqueue(self, item):
        self.stack1.push(item)

    def dequeue(self):
        if self.stack2.isEmpty():
            while not self.stack1.isEmpty():
                self.stack2.push(self.stack1.pop())

        if self.stack2.isEmpty():
            raise IndexError("Queue is empty")
        return self.stack2.pop()

    def peek(self):
        if self.stack2.isEmpty():
            while not self.stack1.isEmpty():
                self.stack2.push(self.stack1.pop())

        if self.stack2.isEmpty():
            raise IndexError("Queue is empty")
        return self.stack2.peek()

    def is_empty(self):
        return self.stack1.isEmpty() and self.stack2.isEmpty()

q2 = QueueUsingStacksDequeueCostly()
q2.enqueue(10)
q2.enqueue(20)
q2.enqueue(30)
print(q2.dequeue())  
print(q2.peek())     
print(q2.is_empty()) 

################################################################################



################################################################################

# ==================== Binary Search Tree ====================

class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None
    
    def insert(self, value):
        if not self.root:
            self.root = Node(value)
        else:
            self._insert_recursive(self.root, value)
    
    def _insert_recursive(self, current_node, value):
        if value < current_node.value:
            if current_node.left is None:
                current_node.left = Node(value)
            else:
                self._insert_recursive(current_node.left, value)
        elif value > current_node.value:
            if current_node.right is None:
                current_node.right = Node(value)
            else:
                self._insert_recursive(current_node.right, value)
        # If value is equal, we typically don't insert duplicates
    
    def search(self, value):
        return self._search_recursive(self.root, value)
    
    def _search_recursive(self, current_node, value):
        if current_node is None:
            return False
        
        if current_node.value == value:
            return True
        elif value < current_node.value:
            return self._search_recursive(current_node.left, value)
        else:
            return self._search_recursive(current_node.right, value)
    
    def delete(self, value):
        self.root = self._delete_recursive(self.root, value)
    
    def _delete_recursive(self, current_node, value):
        if current_node is None:
            return None
        
        # Find the node to delete
        if value < current_node.value:
            current_node.left = self._delete_recursive(current_node.left, value)
        elif value > current_node.value:
            current_node.right = self._delete_recursive(current_node.right, value)
        else:
            # Node with the value to be deleted is found
            
            # Case 1: Leaf node
            if current_node.left is None and current_node.right is None:
                return None
            
            # Case 2: Node with only one child
            if current_node.left is None:
                return current_node.right
            if current_node.right is None:
                return current_node.left
            
            # Case 3: Node with two children
            # Find the minimum value in the right subtree (successor)
            min_node = self._find_min(current_node.right)
            current_node.value = min_node.value
            current_node.right = self._delete_recursive(current_node.right, min_node.value)
        
        return current_node
    
    def _find_min(self, node):
        current = node
        while current.left is not None:
            current = current.left
        return current
    
    def inorder_traversal(self):
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, current_node, result):
        if current_node:
            self._inorder_recursive(current_node.left, result)
            result.append(current_node.value)
            self._inorder_recursive(current_node.right, result)

    def preorder_traversal(self):
        result = []
        self._preorder_recursive(self.root, result)
        return result
    
    def _preorder_recursive(self, current_node, result):
        if current_node:
            result.append(current_node.value)
            self._preorder_recursive(current_node.left, result)
            self._preorder_recursive(current_node.right, result)
    
    def postorder_traversal(self):
        result = []
        self._postorder_recursive(self.root, result)
        return result
    
    def _postorder_recursive(self, current_node, result):
        if current_node:
            self._postorder_recursive(current_node.left, result)
            self._postorder_recursive(current_node.right, result)
            result.append(current_node.value)

def main():
    bst = BinarySearchTree()
    
    values = [50, 30, 70, 20, 40, 60, 80]
    for value in values:
        bst.insert(value)
    
    print("Inorder Traversal:   ", bst.inorder_traversal())
    print("Preorder Traversal:  ", bst.preorder_traversal())
    print("Postorder Traversal: ", bst.postorder_traversal())
    
    print("Search 40:", bst.search(40))
    print("Search 90:", bst.search(90))
    
    bst.delete(30)
    print("Inorder Traversal after deleting 30:", bst.inorder_traversal())

if __name__ == "__main__":
    main()

################################################################################



################################################################################

# ==================== AVL Tree ====================

class AVLNode:
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None
        self.height = 1

class AVLTree:
    def __init__(self):
        self.root = None
    
    def height(self, node):
        if not node:
            return 0
        return node.height
    
    def balance_factor(self, node):
        if not node:
            return 0
        return self.height(node.left) - self.height(node.right)
    
    def update_height(self, node):
        if node:
            node.height = 1 + max(self.height(node.left), self.height(node.right))
    
    def rotate_right(self, y):
        x = y.left
        T2 = x.right
        
        x.right = y
        y.left = T2

        self.update_height(y)
        self.update_height(x)
        
        return x
    
    def rotate_left(self, x):
        y = x.right
        T2 = y.left

        y.left = x
        x.right = T2

        self.update_height(x)
        self.update_height(y)
        
        return y
    
    def insert(self, root, key):
        if not root:
            return AVLNode(key)
        
        if key < root.key:
            root.left = self.insert(root.left, key)
        else:
            root.right = self.insert(root.right, key)
        
        self.update_height(root)
        balance = self.balance_factor(root)
        
        if balance > 1 and key < root.left.key:
            return self.rotate_right(root)
        if balance < -1 and key > root.right.key:
            return self.rotate_left(root)
        if balance > 1 and key > root.left.key:
            root.left = self.rotate_left(root.left)
            return self.rotate_right(root)
        if balance < -1 and key < root.right.key:
            root.right = self.rotate_right(root.right)
            return self.rotate_left(root)
        
        return root
    
    def insert_key(self, key):
        self.root = self.insert(self.root, key)
    
    def min_value_node(self, node):
        current = node
        while current.left:
            current = current.left
        return current
    
    def delete(self, root, key):
        # 1. Perform standard BST deletion
        if not root:
            return root
        
        if key < root.key:
            root.left = self.delete(root.left, key)
        elif key > root.key:
            root.right = self.delete(root.right, key)
        else:
            if not root.left:
                return root.right
            elif not root.right:
                return root.left
            
            temp = self.min_value_node(root.right)
            root.key = temp.key
            root.right = self.delete(root.right, temp.key)
        
        # If the tree had only one node, return
        if not root:
            return root
        
        # 2. Update height of current node
        self.update_height(root)
        
        # 3. Get the balance factor
        balance = self.balance_factor(root)
        
        # 4. Perform rotations if needed
        # Left Left Case
        if balance > 1 and self.balance_factor(root.left) >= 0:
            return self.rotate_right(root)
        
        # Left Right Case
        if balance > 1 and self.balance_factor(root.left) < 0:
            root.left = self.rotate_left(root.left)
            return self.rotate_right(root)
        
        # Right Right Case
        if balance < -1 and self.balance_factor(root.right) <= 0:
            return self.rotate_left(root)
        
        # Right Left Case
        if balance < -1 and self.balance_factor(root.right) > 0:
            root.right = self.rotate_right(root.right)
            return self.rotate_left(root)
        
        return root
    
    def delete_key(self, key):
        self.root = self.delete(self.root, key)
    
    def inorder_traversal(self, root):
        result = []
        if root:
            result.extend(self.inorder_traversal(root.left))
            result.append(root.key)
            result.extend(self.inorder_traversal(root.right))
        return result
    
    def print_tree(self):
        print(self.inorder_traversal(self.root))

def main():
    avl = AVLTree()
    
    keys = [10, 20, 30, 40, 50, 25]
    for key in keys:
        avl.insert_key(key)
    
    print("Original Tree:")
    avl.print_tree()
    
    avl.delete_key(30)
    print("Tree after deleting 30:")
    avl.print_tree()

if __name__ == "__main__":
    main()

################################################################################



################################################################################



################################################################################



################################################################################

# ==================== Binary Heap ====================

class BinaryHeap:
    def __init__(self, heap_type='max'):
        self._heap = []
        self._heap_type = heap_type

    def _compare(self, a, b):
        return a > b if self._heap_type == 'max' else a < b

    def _swap(self, i, j):
        self._heap[i], self._heap[j] = self._heap[j], self._heap[i]

    def _parent_index(self, index):
        return (index - 1) // 2

    def _left_child_index(self, index):
        return 2 * index + 1

    def _right_child_index(self, index):
        return 2 * index + 2

    def _heapify_up(self, index):
        parent = self._parent_index(index)
        
        # If we're at the root or heap property is satisfied, stop
        if index > 0 and self._compare(self._heap[index], self._heap[parent]):
            # Swap with parent
            self._swap(index, parent)
            # Continue heapifying up
            self._heapify_up(parent)

    def _heapify_down(self, index):
        size = len(self._heap)
        left = self._left_child_index(index)
        right = self._right_child_index(index)
        extreme_index = index

        # Check left child
        if (left < size and 
            self._compare(self._heap[left], self._heap[extreme_index])):
            extreme_index = left

        # Check right child
        if (right < size and 
            self._compare(self._heap[right], self._heap[extreme_index])):
            extreme_index = right

        # If extreme index changed, swap and continue heapifying
        if extreme_index != index:
            self._swap(index, extreme_index)
            self._heapify_down(extreme_index)

    def insert(self, value):
        self._heap.append(value)
        self._heapify_up(len(self._heap) - 1)

    def extract_top(self):
        if not self._heap:
            raise IndexError("Heap is empty")
        
        # If only one element, simply pop it
        if len(self._heap) == 1:
            return self._heap.pop()
        
        # Save the top element to return later
        top = self._heap[0]
        
        # Replace root with last element
        self._heap[0] = self._heap.pop()
        
        # Restore heap property
        self._heapify_down(0)
        
        return top

    def peek(self):
        return self._heap[0] if self._heap else None

    def __len__(self):
        return len(self._heap)

    def is_empty(self):
        return len(self._heap) == 0

    def display(self, format='list'):
        if not self._heap:
            print("Heap is empty.")
            return

        if format == 'list':
            # Simple list display
            print(f"{self._heap_type.capitalize()} Heap (list): {self._heap}")
        
        elif format == 'tree':
            # Tree-like display
            def _print_tree(index, prefix='', is_left=True):
                if index >= len(self._heap):
                    return

                # Print right subtree
                right_index = self._right_child_index(index)
                if right_index < len(self._heap):
                    _print_tree(right_index, prefix + ('│   ' if is_left else '    '), False)

                # Print current node
                print(prefix + ('└── ' if is_left else '┌── ') + str(self._heap[index]))

                # Print left subtree
                left_index = self._left_child_index(index)
                if left_index < len(self._heap):
                    _print_tree(left_index, prefix + ('    ' if is_left else '│   '), True)

            print(f"{self._heap_type.capitalize()} Heap (tree):")
            _print_tree(0)
        
        else:
            raise ValueError("Invalid format. Use 'list' or 'tree'.")

def heapsort(arr, reverse=False):
    # Create heap based on desired order
    heap_type = 'max' if not reverse else 'min'
    heap = BinaryHeap(heap_type)
    
    # Insert all elements into heap
    for item in arr:
        heap.insert(item)
    
    # Extract elements to get sorted order
    sorted_arr = []
    while not heap.is_empty():
        sorted_arr.append(heap.extract_top())
    
    return sorted_arr

if __name__ == "__main__":
    print("Max Heap Example:")
    max_heap = BinaryHeap('max')
    max_heap.insert(10)
    max_heap.insert(5)
    max_heap.insert(15)
    max_heap.insert(7)
    
    print("\nMax Heap Display (List Format):")
    max_heap.display('list')
    
    print("\nMax Heap Display (Tree Format):")
    max_heap.display('tree')
    
    print("\nMin Heap Example:")
    min_heap = BinaryHeap('min')
    min_heap.insert(10)
    min_heap.insert(5)
    min_heap.insert(15)
    min_heap.insert(7)
    
    print("\nMin Heap Display (List Format):")
    min_heap.display('list')
    
    print("\nMin Heap Display (Tree Format):")
    min_heap.display('tree')

################################################################################

